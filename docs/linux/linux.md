# linux

## linux内存管理

全文以x64，32位系统为例

### 虚拟地址

为了充分利用和管理系统内存资源，linux采用虚拟内存管理技术，利用虚拟技术，让每个进程都拥有4GB互不干涉的虚拟内存地址空间；

进程初始化和分配的都是基于虚拟地址分配的，只有当进程需要实际访问内存资源的时候，才将虚拟地址与物理地址建立映射关系，调入物理内存页；

虚拟内存的优点：
1. 防止用户直接访问物理内存，做一些破坏性的操作；
2. 每个用户进程都被分配了4GB的虚拟内存地址；可能你的内存都没4GB，但是你却可以获得4GB的内存地址；

虚拟内存对进程而言分为两部分：
1. 用户空间 3GB
2. 内核空间 1GB

#### 用户空间
    
用户能访问的是用户内存空间，用户内存空间地址范围：`0x00000000`至`0xBFFFFFFF`，总容量为3G；

通常情况下，用户只能访问用户空间，但当在执行内陷操作或者系统调用时可以访问内核空间；

##### 进程的内存空间

进程的内存空间按照`访问属性一致的地址空间存放在一起`原则（访问属性指：可读、可写、可执行等）划分为了5个区域；

+ 代码段

    代码段是用来存放可执行文件（二进制文件）的操作指令，可执行程序在内存中的镜像（相当于拷贝了一份运行时的代码）；代码段需要在运行时防止被非法修改，所以是只读段；

+ 数据段

    数据段是用来存放可执行文件中已初始化的全局变量，就是程序中的静态分配的变量和全局变量；

+ BSS段

    BSS段包含了程序中未初始化的全局变量，在内存中BSS段全部置零。

+ 堆 heap

    平时我们所说的堆栈是指栈stack结构，栈stack是类似桶的数据形式，而堆heap则是用`数组`实现的`二叉树`，有兴趣自己去看看，设计很巧妙；
    
    堆是用于存放进程运行中动态分配的内存段，他的大小并不固定，在分配时会动态伸缩；当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）；
    
    程序gc时所释放的内存就是释放这里的内存；

+ 栈 stack

    栈是用来存储用户在程序运行时创建的临时变量，也就是函数中的局部变量；栈是后进先出；除此之外，函数在被调用时，其余参数也会被压入调用者的进程栈中，并且到函数返回后，返回值也会被存放回栈中；当函数执行完成后，他们所占用的内存空间会自动释放，栈内存的分配运算内置在处理器的指令集中，效率很高，但是空间有限；

上述的内存区域，代码段、数据段、BSS通常是被连续的存储在内存中，地址上是连续的，而堆和栈会单独存放；堆在靠BSS段，同时地址向上扩展；栈在上方，向下扩展；堆和栈中间是内存映射段，它是高效的I/O映射方式，用于装载一个共享的动态内存库，用户可使用系统接口创建共享内存，做进程间通信；

<div align="center">
    <img src="_media/memstruct.svg">
</div>

#### 内核空间

在`x86 32`位系统里，Linux内核地址空间是指虚拟地址从`0xC0000000`开始到`0xFFFFFFFF`为止的高端内存地址空间，总计1G的容量，包括了内核镜像、物理页面表、驱动程序等运行在内核空间；

### 物理地址

当用户需要使用内存时，就需要将虚拟内存地址映射到物理地址，物理地址就是在内存上的地址；这中间涉及利用`MMU`内存管理单元（Memory Management Unit) 对虚拟地址分段和分页（段页式）地址转换，关于分段和分页的具体流程，这里不详细描述；

